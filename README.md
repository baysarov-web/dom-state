# DOM ToDo List with State

## Summary

Необходимо сделать вывод элементов списка дел, которые заранее составлены и хранятся в переменной.

Отличие данного челленджа от предыдущих в том, что мы не будем работать с DOM напрямую для добавления/удаления элементов.

Вместо этого мы будем работать с массивом из нашего кода добавляя и удаляя из него элементы. После изменения массива мы перезапишем DOM-узлы таким образом, чтобы они отображали текущее состояние переменной.

## Releases

### Pre release 

Подготовься к данному челленджу повторив темы из раздела "Массивы".

Вспомни как создавать массив, добавлять элементы, удалять элементы и обходить массив в цикле.

Вспомни про такую структуру данных, как массив из объектов.

Также повтори и закрепи методы для работы с DOM-деревом.

Потрать на пре-релиз 30 минут. Накидай в черновике код, в котором бы выполнялись все операции над массивом.

### Release 0

Создай простую HTML-страницу для вывода списка дел. Не трать время на дизайн. Главное правильно составить структуру страницы.

Подготовь на странице `div` с идентификатором `list`. Позднее мы будем записывать в этот контейнер элементы списка дел.

Также не забудь разместить на странице окно ввода и кнопку для добавления.

### Release 1

В файле `state-dom.js` создай массив из пяти элементов.

Каждый элемент массива – это отдельный элемент списка дел, то есть одно конкретное добавленное дело.

Помимо текста самого дела нужно также держать информацию о том выполнено данное дело или нет. По этой причине хранить в массиве просто строки недостаточно. Необходимо хранить объекты такого вида:

```
{
  text: "первое дело",     <- текст дела
  done: true               <- выполнено дело или нет
}
```

### Release 2

В этом релизе мы будем выводить каждый элемент списка дел на страницу.

Данная логика должна быть реализована в функции `render()`. На вход этой функции будет передаваться тот самый массив из релиза 1.

Задача функции `render()` обходить массив со списком дел через цикл. При каждой итерации текущее дело должно быть добавлено в конец контейнера `#list`.

Примерный алгоритм функции `render()`:

``` 
получить узел #list
цикл для обхода массива
  создать новый узел
  добавить для узла textContent, который равен тексту текущего элемента массива
  добавить созданный узел в конец узла #list
```

В конце файла `state-dom.js` вызови эту функцию, передав в неё массив списка дел.

### Release 3

Теперь, когда элементы начали выводиться на страницу доработай её дизайн. Поставь отступы, поменяй цвета, измени шрифт.

⚠️ Мы все еще нигде не использовали ключ `done` из нашего объекта. Это не ошибка. Мы вернёмся к нему позже в других релизах. Делать сейчас чекбоксы для списка не нужно.

### Release 4

Напиши функцию `remove()`, которая будет принимать индекс и удалять соответствующий элемент из массива.

В конце функции `remove()` должна вызываться функция `render()`, т.к. после удаления элементы на странице нужно переписать, чтобы они соответствовали текущему значению массива.

Для проверки правильности вызови функцию `remove()` через консоль.

После текущего релиза у тебя получится примерно такое приложение:

![](./assets/00.gif)

### Release 4.1 (bug fix)

После вызова функции `remove()` элементы на странице не обновляются, а дописываются в конец списка. Это логично, так как мы использовали метод `.append()` (кто-то возможно `.prepend()`), а он дописывает указанные элементы в конец узла, не удаляя те, что там уже имеются.

Исправить этот баг нужно в функции `render()`. В самом начале функции необходимо очистить содержимое узла `#list` и только потом начать добавлять элементы.

Как очистить узел от всех дочерних элементов узнай на следующей странице: [https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript](https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript). 

Найди решение и примени его в своей функции.

### Release 5

Напиши функцию `addTodo()`, которая принимает на вход текст нового дела и добавляет это дело в конец массива. Не забывай, что все элементы массива должны быть объектами с одинаковыми ключами.

Как и в случае с функцией `remove()` добавь в конце вызов `render()`, чтобы после добавления нового дела страница перезаписывалась.

Вызови функцию `addTodo()` в консоли, передай нужный параметр и проверь правильность её работы.

После текущего релиза у тебя должен быть примерно такой функционал:

![](./assets/01.gif)

### Release 6

После предыдущих релизов у тебя есть
- a) форма ввода нового дела и кнопка добавления
- b) функция `addTodo()`, умеющая добавлять новые дела в массив.

Объедини эти два функционала в единое целое.

Предоставь пользователю возможность добавлять новые дела с помощью формы, а не консоли. 

После добавления поле ввода должно очищаться.

Состояние приложения после текущего релиза:

![](./assets/02.gif)

### Release 7

Добавь к каждому элементу кнопку с возможностью удаления. При клике на кнопку должна вызываться функция `remove()`, куда передается индекс текущего элемента.

Состояние приложения после текущего релиза:

![](./assets/03.gif)

### Release 8

Пора дать возможность пользователю отмечать дела выполненными. 

В релизе 1 создавая объект дела мы добавили в объект свойство `done`, однако до сих пор никак его не использовали.

Создай функцию `checkTodo()`, которая принимает в качестве параметра индекс элемента и меняет свойство `done` этого элемента на противоположное(см. [оператор инверсии](https://learn.javascript.ru/logical-ops#ne))

Затем доработай функцию `render()` так, чтобы она добавляла к списку дел галочку с обработчиком события. Обработчик должен вызывать функцию `checkTodo`, передавая в неё номер текущей итерации цикла.

Добавь также оформление, чтобы отмеченные дела выделялись от остальных.

Состояние приложения после текущего релиза:

![](./assets/04.gif)

### Release 9. Code refactoring

Отдохни после предыдущих релизов как минимум 20 минут. Затем вернись к коду и выполни следующие задания:
- сделай код более читабельным;
- измени названия переменных на более информативные;
- добавь комментарии к каждой строке с подробным описанием;
- если ты использовал свойство `.className`, то замени его на `classList`;
- прочитай про тег `<form>`, про событие `submit` и про метод `.preventDefault()`. Попытайся использовать эти знания для доработки приложения.

## Conclusion (заключение)

После выполнения всех релизов открой файл `reference.html` из текущей папки и сравни своё решение с эталонным.

⚠️⚠️⚠️ НИ В КОЕМ СЛУЧАЕ НЕ ОТКРЫВАЙ ЭТОТ ФАЙЛ ПОКА НЕ СДАШЬ ВСЕ РЕЛИЗЫ. НЕЛЬЗЯ ПОДСМАТРИВАТЬ НИ ОДИН СИМВОЛ ИЗ НЕГО!!!

После этого ответь на вопросы:
- отличался ли ход твоего решения от эталонного кардинально?
- какие свойства/методы из эталонного решения ты видел впервые?
- можно ли как-то улучшить этот код? 

Поработай над своими ответами. К примеру, если ты встретил новые свойства/методы, то прочитай про них дополнительно и изучи.
Если отличие твоего кода от эталонного было сильным, то определи участки, которые более всего отличилась и постарайся запомнить их, чтобы в будущем применять эти решения на практике.

Несмотря на небольшой функционал данная работа включает в себя множество важных тем, связанных именно с ходом решения.

Если посмотреть на код глобально, то можно обнаружить, что на самом деле мы работаем с массивом из объектов, который находится внутри нашего кода. Затем мы выводим текущее состояние переменной в браузер пользователя. Мы еще много раз вернемся к данному подходу во время обучения.

✅ Данный челлендж будет считаться выполненным после того, как ты сможешь написать повторно весь код приложения не подсматривая в старый.
